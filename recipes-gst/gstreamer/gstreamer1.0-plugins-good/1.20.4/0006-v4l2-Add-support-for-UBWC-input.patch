From be81845ee63ba8d13a26782d452ac648a951417d Mon Sep 17 00:00:00 2001
From: Raja Ganapathi Busam <quic_rbusam@quicinc.com>
Date: Sat, 10 Feb 2024 20:18:27 +0530
Subject: [PATCH] v4l2: Add support for UBWC input

Signed-off-by: Raja Ganapathi Busam <quic_rbusam@quicinc.com>

---
 sys/v4l2/gstv4l2.c          |  8 ++++++++
 sys/v4l2/gstv4l2allocator.c | 28 ++++++++++++++++++++++++----
 sys/v4l2/gstv4l2allocator.h |  1 +
 sys/v4l2/gstv4l2imagepool.c |  8 ++++----
 sys/v4l2/gstv4l2object.c    | 32 ++++++++++++++++++++++++++++----
 sys/v4l2/gstv4l2videoenc.c  |  6 +++---
 6 files changed, 68 insertions(+), 15 deletions(-)

diff --git a/sys/v4l2/gstv4l2.c b/sys/v4l2/gstv4l2.c
index ec53bc9..b7ff559 100644
--- a/sys/v4l2/gstv4l2.c
+++ b/sys/v4l2/gstv4l2.c
@@ -113,6 +113,14 @@ gst_v4l2_probe_template_caps (const gchar * device, gint video_fd,
 
       if (alt_t)
         gst_caps_append_structure (caps, alt_t);
+
+      if (gst_structure_has_name (template, "video/x-raw")) {
+        alt_t = gst_structure_copy (template);
+        gst_caps_append_structure (caps, alt_t);
+        gst_caps_set_features (caps, gst_caps_get_size (caps) - 1,
+            gst_caps_features_new ("memory:GBM", NULL));
+      }
+      GST_DEBUG ("caps = %" GST_PTR_FORMAT, caps);
     }
   }
 
diff --git a/sys/v4l2/gstv4l2allocator.c b/sys/v4l2/gstv4l2allocator.c
index 632c135..f9deabf 100644
--- a/sys/v4l2/gstv4l2allocator.c
+++ b/sys/v4l2/gstv4l2allocator.c
@@ -359,8 +359,11 @@ gst_v4l2_allocator_release (GstV4l2Allocator * allocator, GstV4l2Memory * mem)
 
   switch (allocator->memory) {
     case V4L2_MEMORY_DMABUF:
-      close (mem->dmafd);
-      mem->dmafd = -1;
+      if (mem->is_local_fd) {
+        GST_LOG_OBJECT (allocator, "closing fd: %d", mem->dmafd);
+        close (mem->dmafd);
+        mem->dmafd = -1;
+      }
       break;
     case V4L2_MEMORY_USERPTR:
       mem->data = NULL;
@@ -1124,6 +1127,7 @@ gst_v4l2_allocator_import_dmabuf (GstV4l2Allocator * allocator,
   GstV4l2Object *obj = allocator->obj;
   GstV4l2Memory *mem;
   gint i;
+  gboolean is_local_fd = FALSE;
 
   g_return_val_if_fail (allocator->memory == V4L2_MEMORY_DMABUF, FALSE);
 
@@ -1148,6 +1152,7 @@ gst_v4l2_allocator_import_dmabuf (GstV4l2Allocator * allocator,
 
       GST_DEBUG_OBJECT (allocator, "Memory %i is not of DMABUF", i);
 
+      // Get the driver proposed size
       maxsize = (V4L2_TYPE_IS_MULTIPLANAR (obj->type) ?
         obj->format.fmt.pix_mp.plane_fmt[i].sizeimage :
         obj->format.fmt.pix.sizeimage);
@@ -1169,12 +1174,20 @@ gst_v4l2_allocator_import_dmabuf (GstV4l2Allocator * allocator,
 
       gst_memory_map (dma_mem[i], &info, GST_MAP_READ);
 
-      memcpy (data, info.data, dma_mem[i]->size);
+      // Check if the buffer size is greater than driver proposed size
+      // if yes, copy only driver proposed size of bytes from buffer
+      // if no, copy buffer size of bytes from buffer
+      size = dma_mem[i]->size > maxsize ? maxsize : dma_mem[i]->size;
+      GST_DEBUG_OBJECT(allocator, "copying buffer size: %u", size);
+
+      memcpy (data, info.data, size);
 
       gst_memory_unmap (dma_mem[i], &info);
       if (munmap (data, maxsize))
         GST_WARNING_OBJECT (allocator, "Failed to unmap memory with error: %s",
         g_strerror (errno));
+
+      is_local_fd = TRUE;
     }
 
     GST_LOG_OBJECT (allocator, "[%i] imported DMABUF as fd %i plane %d",
@@ -1187,6 +1200,7 @@ gst_v4l2_allocator_import_dmabuf (GstV4l2Allocator * allocator,
     mem->mem.offset = offset;
     mem->mem.size = size;
     mem->dmafd = dmafd;
+    mem->is_local_fd = is_local_fd;
 
     /* Update v4l2 structure */
     group->planes[i].length = maxsize;
@@ -1327,9 +1341,12 @@ gst_v4l2_allocator_qbuf (GstV4l2Allocator * allocator,
 
   /* update sizes */
   if (V4L2_TYPE_IS_MULTIPLANAR (obj->type)) {
-    for (i = 0; i < group->n_mem; i++)
+    for (i = 0; i < group->n_mem; i++) {
       group->planes[i].bytesused =
           gst_memory_get_sizes (group->mem[i], NULL, NULL);
+      GST_LOG_OBJECT (allocator, "multiplanar data i[%d] length: %u bytesused:%u fd: %u",
+        i, group->planes[i].length, group->planes[i].bytesused, group->planes[i].m.fd);
+    }
   } else {
     group->buffer.bytesused = gst_memory_get_sizes (group->mem[0], NULL, NULL);
   }
@@ -1338,6 +1355,9 @@ gst_v4l2_allocator_qbuf (GstV4l2Allocator * allocator,
   for (i = 0; i < group->n_mem; i++)
     gst_memory_ref (group->mem[i]);
 
+  GST_LOG_OBJECT (allocator, "Queue buffer:: index:%u bytesused:%u fd: %d",
+      group->buffer.index, group->buffer.bytesused, group->buffer.m.fd);
+
   if (obj->ioctl (obj->video_fd, VIDIOC_QBUF, &group->buffer) < 0) {
     GST_ERROR_OBJECT (allocator, "failed queueing buffer %i: %s",
         group->buffer.index, g_strerror (errno));
diff --git a/sys/v4l2/gstv4l2allocator.h b/sys/v4l2/gstv4l2allocator.h
index 2166b6b..06c74b9 100644
--- a/sys/v4l2/gstv4l2allocator.h
+++ b/sys/v4l2/gstv4l2allocator.h
@@ -81,6 +81,7 @@ struct _GstV4l2Memory
   GstV4l2MemoryGroup *group;
   gpointer data;
   gint dmafd;
+  gboolean is_local_fd;
 };
 
 struct _GstV4l2MemoryGroup
diff --git a/sys/v4l2/gstv4l2imagepool.c b/sys/v4l2/gstv4l2imagepool.c
index 02f58aa..6f60140 100644
--- a/sys/v4l2/gstv4l2imagepool.c
+++ b/sys/v4l2/gstv4l2imagepool.c
@@ -232,8 +232,8 @@ open_gbm_device (GstV4l2ImageBufferPool * vpool)
     return FALSE;
   }
 
-  GST_INFO_OBJECT (vpool, "Open /dev/dma_heap/system");
-  priv->devfd = open ("/dev/dma_heap/system", O_RDONLY | O_CLOEXEC);
+  GST_INFO_OBJECT (vpool, "Open /dev/dma_heap/qcom,system");
+  priv->devfd = open ("/dev/dma_heap/qcom,system", O_RDONLY | O_CLOEXEC);
 
   if (priv->devfd < 0) {
     GST_ERROR_OBJECT (vpool, "Failed to open GBM device FD!");
@@ -320,8 +320,8 @@ open_dma_device (GstV4l2ImageBufferPool * vpool)
 {
   GstV4l2ImageBufferPoolPrivate *priv = vpool->priv;
 
-  GST_INFO_OBJECT (vpool, "Open /dev/dma_heap/system");
-  priv->devfd = open ("/dev/dma_heap/system", O_RDONLY | O_CLOEXEC);
+  GST_INFO_OBJECT (vpool, "Open /dev/dma_heap/qcom,system");
+  priv->devfd = open ("/dev/dma_heap/qcom,system", O_RDONLY | O_CLOEXEC);
 
   if (priv->devfd < 0) {
     GST_ERROR_OBJECT (vpool, "Failed to open DMA device FD!");
diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index 87f86da..dca1d8a 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -397,7 +397,8 @@ gst_v4l2_object_install_properties_helper (GObjectClass * gobject_class,
   g_object_class_install_property (gobject_class, PROP_EXTRA_CONTROLS,
       g_param_spec_boxed ("extra-controls", "Extra Controls",
           "Extra v4l2 controls (CIDs) for the device",
-          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+          GST_TYPE_STRUCTURE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_MUTABLE_PLAYING));
 
   /**
    * GstV4l2Src:pixel-aspect-ratio:
@@ -462,7 +463,8 @@ gst_v4l2_object_install_m2m_properties_helper (GObjectClass * gobject_class)
   g_object_class_install_property (gobject_class, PROP_EXTRA_CONTROLS,
       g_param_spec_boxed ("extra-controls", "Extra Controls",
           "Extra v4l2 controls (CIDs) for the device",
-          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+          GST_TYPE_STRUCTURE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_MUTABLE_PLAYING));
 }
 
 /* Support for 32bit off_t, this wrapper is casting off_t to gint64 */
@@ -1659,7 +1661,7 @@ static void
 add_alternate_variant (GstV4l2Object * v4l2object, GstCaps * caps,
     GstStructure * structure)
 {
-  GstStructure *alt_s;
+  GstStructure *alt_s, *alt_s2;
 
   if (v4l2object && v4l2object->never_interlaced)
     return;
@@ -1672,6 +1674,10 @@ add_alternate_variant (GstV4l2Object * v4l2object, GstCaps * caps,
 
   gst_caps_append_structure_full (caps, alt_s,
       gst_caps_features_new (GST_CAPS_FEATURE_FORMAT_INTERLACED, NULL));
+
+  alt_s2 = gst_structure_copy (structure);
+  gst_caps_append_structure_full (caps, alt_s2,
+      gst_caps_features_new ("memory:GBM", NULL));
 }
 
 static GstCaps *
@@ -3534,6 +3540,19 @@ field_to_str (enum v4l2_field f)
   return "unknown";
 }
 
+static gboolean
+caps_has_compression (const GstCaps * caps, const gchar * compression)
+{
+  GstStructure *structure = NULL;
+  const gchar *string = NULL;
+
+  structure = gst_caps_get_structure (caps, 0);
+  string = gst_structure_has_field (structure, "compression") ?
+      gst_structure_get_string (structure, "compression") : NULL;
+
+  return (g_strcmp0 (string, compression) == 0) ? TRUE : FALSE;
+}
+
 static gboolean
 gst_v4l2_object_set_format_full (GstV4l2Object * v4l2object, GstCaps * caps,
     gboolean try_only, GstV4l2Error * error)
@@ -3574,7 +3593,12 @@ gst_v4l2_object_set_format_full (GstV4l2Object * v4l2object, GstCaps * caps,
   if (!gst_v4l2_object_get_caps_info (v4l2object, caps, &fmtdesc, &info))
     goto invalid_caps;
 
-  pixelformat = fmtdesc->pixelformat;
+  if (V4L2_TYPE_IS_OUTPUT (v4l2object->type) &&
+      caps_has_compression (caps, "ubwc"))
+      pixelformat = V4L2_PIX_FMT_QC08C;
+  else
+    pixelformat = fmtdesc->pixelformat;
+
   width = GST_VIDEO_INFO_WIDTH (&info);
   height = GST_VIDEO_INFO_FIELD_HEIGHT (&info);
   fps_n = GST_VIDEO_INFO_FPS_N (&info);
diff --git a/sys/v4l2/gstv4l2videoenc.c b/sys/v4l2/gstv4l2videoenc.c
index f9ba215..6c66b6d 100644
--- a/sys/v4l2/gstv4l2videoenc.c
+++ b/sys/v4l2/gstv4l2videoenc.c
@@ -587,9 +587,9 @@ gst_v4l2_video_enc_negotiate (GstVideoEncoder * encoder)
     /* negotiate_profile_and_level() will return TRUE on failure to keep
      * iterating, if gst_caps_foreach() returns TRUE it means there was no
      * compatible profile and level in any of the structure */
-    if (gst_caps_foreach (allowed_caps, negotiate_profile_and_level, &ctx)) {
-      goto no_profile_level;
-    }
+//    if (gst_caps_foreach (allowed_caps, negotiate_profile_and_level, &ctx)) {
+//      goto no_profile_level;
+//    }
 
     gst_caps_unref (allowed_caps);
     allowed_caps = NULL;
